var documenterSearchIndex = {"docs":
[{"location":"sayhello/#Introduction","page":"Macro call explained","title":"Introduction","text":"","category":"section"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"macro returns expression, and the ex::Expr is executed in the scope just like @eval(mod::Module, ex) (mod can be Main).","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"macro f45()\n    return quote\n        x = 5 \n        f(45)\n    end\nend","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"f = sin\n@f45","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"f = tan\n@f45","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"Although the returned expression can \"see\" the scope where the macro is defined, variable defined in expression won't contaminate the surrounded scope,","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"@f45\n\nx","category":"page"},{"location":"sayhello/#Use-macro-or-@evaluate-an-*expression*","page":"Macro call explained","title":"Use macro or @evaluate an expression","text":"","category":"section"},{"location":"sayhello/#*expression*-is-executed-in-the-scope-where-the-macro-is-defined","page":"Macro call explained","title":"expression is executed in the scope where the macro is defined","text":"","category":"section"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"Execution of macro are isolated in the module where it is defined, just like a function.","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"As a consequence, macro hygiene is easy to maintain, that  it is generally safe to use macro defined in a clean module.","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"The expression returned by macro can \"see\" the surrounding scope (e.g., Main)","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"In this example,  You can redefine variables in HelloWorld, and ","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"module HelloWorld\n    f = sin\n\n    macro definex(x)\n        return quote\n            HelloWorld.x = $x # This is the `x` in `definex(x)`\n            HelloWorld.f = f\n        end\n    end\n\n    macro f(x)\n        return :(f($x))\n    end\n\n    HelloWorld.x = 5.99\nend","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"using .HelloWorld\n\nx = π/2\nf = cos","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"@f takes HelloWorld.f (which is sin), not f of Main (f = cos):","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"HelloWorld.@f π/2","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"@definex 0 redefine HelloWorld.x = 0 and HelloWorld.f as the global f of HelloWorld:","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"HelloWorld.@definex 0\nHelloWorld.x","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"HelloWorld.f","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"They are not interacted with the x and f of the scope that calls the macro at all.","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"(x, f)","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"No matter whether @definex is exported or not:","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"module HelloWorld\n    f = sin\n\n    macro definex(x)\n        return quote\n            HelloWorld.x = $x # This is the `x` in `definex(x)`\n            HelloWorld.f = f\n            f2($x)\n        end\n    end\n\n    macro f(x)\n        return :(f($x))\n    end\n\n    HelloWorld.x = 5.99\n    export @definex\nend\n\nusing .HelloWorld\n\nx = π/2; f = cos; f2 = tan;\n\nHelloWorld.@f π/2\n\n@definex 0\n\nHelloWorld.x\n\nHelloWorld.f\n\n(x, f)","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"tip: Summary\nExpression returned by macro is executed in the scope where the macro is defined, NOT where the the macro is called.\nThis is evident as @definex use f defined in module HelloWorld ... end, and f2 is unseen.","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"Use esc to escape the expression from the scope of HelloWorld, that f2 can thus be seen:","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"module HelloWorld\n    macro f(x)\n        return :(f($x))\n    end\n    export @f\nend\n\nusing .HelloWorld\n\nf = sin\n\n@f 5","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"module HelloWorld\n    macro f(x)\n        expr = :(f($x))\n        return :($(esc(expr)))\n    end\n    export @f\nend\n\nusing .HelloWorld\n\nf = sin\n\n@f 5","category":"page"},{"location":"sayhello/#The-same-result/utility-can-be-achieved-with-function-using-@eval:","page":"Macro call explained","title":"The same result/utility can be achieved with function using @eval:","text":"","category":"section"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"module HelloWorld\n    f = sin\n\n    function definex(x)\n        ex = quote\n            HelloWorld.x = $x\n            HelloWorld.sinx = f($x)\n        end\n        @eval $ex\n    end\n\n    HelloWorld.x = 5.99\n    HelloWorld.sinx = f(x)\nend\nHelloWorld.sinx","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"HelloWorld.definex(0)\nx = 5\nHelloWorld.x","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"HelloWorld.sinx","category":"page"},{"location":"sayhello/#Be-ware-of-the-difference-between-@eval-ex-and-@eval-ex","page":"Macro call explained","title":"Be ware of the difference between @eval ex and @eval $ex","text":"","category":"section"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"f = sin\nx = 0\nex = quote\n    x = $x\n    sinx = f($x)\nend","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"@eval ex\n@macroexpand @eval ex\nsinx","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"The ERROR: UndefVarError: 'sinx' not defined occurred since ex is passed to @eval as Symbol; thus, nothing executed.  Noted that ERROR: UndefVarError: 'ex' not defined won't be raised when ex is not defined!","category":"page"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"@eval $ex\n@macroexpand @eval $ex\nsinx","category":"page"},{"location":"sayhello/#Reference","page":"Macro call explained","title":"Reference","text":"","category":"section"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"Emma Boudreau - Metaprogramming in Julia: A Full Overview","category":"page"},{"location":"sayhello/#Tips","page":"Macro call explained","title":"Tips","text":"","category":"section"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"tip: Tips\nMultiline quote ... end is in fact Expr(:block, ex1, ex2, ...)\nesc escape ex::Expr from macro expansion; it is used to \"violate\" macro hygiene when necessary. See Metaprogramming/#Hygiene.\nmacroexpand and @macroexpand is very useful in debugging. See metaprogramming/#Hold-up:-why-macros?","category":"page"},{"location":"sayhello/#Example","page":"Macro call explained","title":"Example","text":"","category":"section"},{"location":"sayhello/#Say-Hello","page":"Macro call explained","title":"Say Hello","text":"","category":"section"},{"location":"sayhello/#the-say-hello-function","page":"Macro call explained","title":"the say-hello function","text":"","category":"section"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"WorkingScopes.sayhello3","category":"page"},{"location":"sayhello/#WorkingScopes.sayhello3","page":"Macro call explained","title":"WorkingScopes.sayhello3","text":"sayhello3(name) = \"Hello world! $name\", an example to understand metaprogramming.\n\n\n\n\n\n","category":"function"},{"location":"sayhello/#The-say-hello-macro-built-upon","page":"Macro call explained","title":"The say-hello macro built upon","text":"","category":"section"},{"location":"sayhello/","page":"Macro call explained","title":"Macro call explained","text":"WorkingScopes.@sayhello3","category":"page"},{"location":"sayhello/#WorkingScopes.@sayhello3","page":"Macro call explained","title":"WorkingScopes.@sayhello3","text":"macro sayhello3(str::String)\n    return Expr(:block, :(sayhello3($str)))\nend\n\nExample\n\nWorkingScopes.@sayhello3 \"Bruce Willey\"\n\n# output\n\"Hello world! Bruce Willey\"\n\n\n\n\n\nmacro sayhello3(ex::Expr)\n    return Expr(:block, :(sayhello3($(last(ex.args)))))\nend\n\nExample: variable name is not defined in macro's scope\n\nname = \"Bruce Willey\"\n\n# output\n\"Bruce Willey\"\n\njulia> WorkingScopes.@sayhello3 $name\nERROR: UndefVarError: `name` not defined\n\ntip: Explain\nname is passed as expression in this case, and it is not defined since macro dispatch is not based on the AST evaluated at runtime. Thus an error of UndefVarError is raised.\nSee Macros and dispatch for more information.\n\nExample: a creative application\n\nWorkingScopes.@sayhello3 name = \"Bruce Willey\"\n\n# output\n\"Hello world! Bruce Willey\"\n\ntip: Explain\nIn this example, the last argument of the expression name = \"Bruce Willey\" is \"Bruce Willey\".\n\nExample 3: Use @eval if you want name be evaluated\n\n@eval WorkingScopes.@sayhello3 $name\n\n# output\n\"Hello world! Bruce Willey\"\n\ntip: Explain\n@eval evalute the expression @sayhello3 $name at runtime.\nThus, the argument for @sayhello3 is evaluated as String, and @sayhello3(str::String) is the dispatched method.\n\n\n\n\n\nmacro sayhello3(symb::Symbol)\n    return Expr(:block, :(sayhello3($(string(symb)))))\nend\n\nExample: A single the runtime variable is rendered as Symbol\n\nname = \"Bruce Willey\"\nWorkingScopes.@sayhello3 name\n\n# output\n\"Hello world! name\"\n\n\n\n\n\n","category":"macro"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"Referring Scope of Variables","category":"page"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"All variable lives in the name space of a certain module.","category":"page"},{"location":"scopeconstruct/#Keynotes","page":"Scope constructs","title":"Keynotes","text":"","category":"section"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"Global variable lives in module scope and there is no all-encompassing global scope.\n\"in a scope, each variable can only have one meaning, and that meaning is determined regardless of the order of expressions\"","category":"page"},{"location":"scopeconstruct/#Soft-scope","page":"Scope constructs","title":"Soft scope","text":"","category":"section"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"for, while, try are soft.","category":"page"},{"location":"scopeconstruct/#Cases-where-global-x-will-not-modified","page":"Scope constructs","title":"Cases where global x will not modified","text":"","category":"section"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"x is created/modified as local if ...","category":"page"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"\ntry\n    x = 1\n    @assert x == 1\ncatch e\n    throw(e)\nend\n\nx\n","category":"page"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"x = 5\n\ntry\n    x = 1\n    @assert x == 1\ncatch e\n    throw(e)\nend\n\nx\n","category":"page"},{"location":"scopeconstruct/#Will-global-x-will-be-modified?","page":"Scope constructs","title":"Will global x will be modified?","text":"","category":"section"},{"location":"scopeconstruct/#In-interactive-context:-global-x-is-modified","page":"Scope constructs","title":"In interactive context: global x is modified","text":"","category":"section"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"Global x (the x=5 one) is assigned.  This feature allows moving code back and forth between a function body and REPL when trying to debug.","category":"page"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"x = 5\n\ntry\n    x = 1\n    x = x + 1\n    @assert x == 2\ncatch e\n    throw(e)\nend\n\nx\n","category":"page"},{"location":"scopeconstruct/#In-non-interactive-context:-you-get-a-warning","page":"Scope constructs","title":"In non-interactive context: you get a warning","text":"","category":"section"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"Global x (the x=5 one) is NOT assigned!","category":"page"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"code = \"\"\"\nx = 5\n\ntry\n    x = 1\n    x = x + 1\n    @assert x == 2\ncatch e\n    throw(e)\nend\n\"\"\"\n\ninclude_string(@__MODULE__, code)\n","category":"page"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"The x of x = 5  remains safe!","category":"page"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"x ","category":"page"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"You can disambiguate by using local x = 1 to suppress this warning.","category":"page"},{"location":"scopeconstruct/#Brief-summary","page":"Scope constructs","title":"Brief summary","text":"","category":"section"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"You can \"see\" variable outside the current soft scope; you can use it's value but assignment to it (the outsider) is not allowed, unless you are in a interactive context.","category":"page"},{"location":"scopeconstruct/#Hard-scope","page":"Scope constructs","title":"Hard scope","text":"","category":"section"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"Rules for hard scope is simple. Please refer to julia's documentation variables and scoping/local scope. Here I'm showing some surprising examples:","category":"page"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"module Hello\n    function brutalredef(y)\n        Hello.x = y\n        return nothing\n    end\n    Hello.x = 4.99\nend\n\nusing .Hello\n\nHello.x\n\nHello.brutalredef(12)\n\nHello.x","category":"page"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"You can redefine variables/functions this way.","category":"page"},{"location":"scopeconstruct/#Hard-in-hard","page":"Scope constructs","title":"Hard in hard","text":"","category":"section"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"\"the local scope of a for loop body is no different from the local scope of an inner function\"\n\"you can generally move code in or out of an inner function without changing its meaning\"\nx = <value> in hard scope: \"If x is not already a local variable and assignment occurs inside of any hard scope construct (i.e. within a let block, function or macro body, comprehension, or generator), a new local named x is created in the scope of the assignment\"","category":"page"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"function sum_to_def_closure(n)\n    function loop_body(i)\n        t = s + i # new local `t`\n        s = t # assign same local `s` as below\n    end\n    s = 0 # new local\n    for i = 1:n\n        loop_body(i)\n    end\n    return s, @isdefined(t)\nend\n\nsum_to_def_closure(10)","category":"page"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"let n=10\n    function loop_body(i)\n        t = s + i # new local `t`\n        s = t # assign same local `s` as below\n    end\n    s = 0 # new local\n    for i = 1:n\n        loop_body(i)\n    end\n    (s, @isdefined(t))\nend","category":"page"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"function sum_to_def_closure(n)\n    s = 0\n    let\n      for i = 1:n\n          t = s + i # new local `t`\n          s = t # assign same local `s` as below\n      end\n    end\n    return s, @isdefined(t)\nend\n\nsum_to_def_closure(10)","category":"page"},{"location":"scopeconstruct/#Hard-in-soft","page":"Scope constructs","title":"Hard in soft","text":"","category":"section"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"You should be ware of the warning!","category":"page"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"code = \"\"\"\ns = try \n    n = 10\n    s = 0 # new local\n    function loop_body(i)\n        t = s + i # new local `t`\n        s = t # assign same local `s` as below\n    end\n    for i = 1:n\n        loop_body(i)\n    end\n    s\ncatch e\n    throw(e)\nend\n\nshow(s)\n\"\"\"\n\ninclude_string(@__MODULE__, code)","category":"page"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"note: Explain\n","category":"page"},{"location":"scopeconstruct/#Hard-in-Module","page":"Scope constructs","title":"Hard in Module","text":"","category":"section"},{"location":"scopeconstruct/","page":"Scope constructs","title":"Scope constructs","text":"module SumDef\n    s = 0\n    function loop_body(i)\n        t = s + i # new local `t`\n        s = t # assign same local `s` as below\n    end\n    for i = 1:10\n        loop_body(i)\n    end\nend\n\nusing .SumDef\n\nSumDef.s","category":"page"},{"location":"importusing/#Import-and-Using","page":"Import and Using","title":"Import and Using","text":"","category":"section"},{"location":"importusing/#Example-1:-Variable-of-the-same-name-are-separated-by-module","page":"Import and Using","title":"Example 1: Variable of the same name are separated by module","text":"","category":"section"},{"location":"importusing/","page":"Import and Using","title":"Import and Using","text":"module Bar\n    x = 1\n    foo() = x\n    export foo\nend","category":"page"},{"location":"importusing/","page":"Import and Using","title":"Import and Using","text":"\nimport .Bar\n\nfoo()\n\nx = -1;\n\nBar.foo()\n\nBar.x\n","category":"page"},{"location":"importusing/#Example-2:-Redefine/Assign-exported-global-variable?","page":"Import and Using","title":"Example 2: Redefine/Assign exported global variable?","text":"","category":"section"},{"location":"importusing/","page":"Import and Using","title":"Import and Using","text":"It is not allowed once x is \"called\":","category":"page"},{"location":"importusing/","page":"Import and Using","title":"Import and Using","text":"module Bar2\n    x = 1\n    foo() = x\n    export foo\n    export x # note the difference\nend","category":"page"},{"location":"importusing/","page":"Import and Using","title":"Import and Using","text":"\nusing .Bar2\n\nx # Here is the difference!\n\nx = -1\n\nfoo()\n\nx === Bar2.x","category":"page"},{"location":"importusing/","page":"Import and Using","title":"Import and Using","text":"But it is allowed before x is called","category":"page"},{"location":"importusing/","page":"Import and Using","title":"Import and Using","text":"module Bar2\n    x = 1\n    foo() = x\n    export foo\n    export x # note the difference\nend","category":"page"},{"location":"importusing/","page":"Import and Using","title":"Import and Using","text":"\nusing .Bar2\n\nx = -1\n\nfoo()\n\nx === Bar2.x","category":"page"},{"location":"importusing/#Difference-between-using-and-import","page":"Import and Using","title":"Difference between using and import","text":"","category":"section"},{"location":"importusing/#Extensibility-of-function","page":"Import and Using","title":"Extensibility of function","text":"","category":"section"},{"location":"importusing/","page":"Import and Using","title":"Import and Using","text":"Function are extensible under the introduced module (e.g., Bar) for both using and import cases.\nOnly explicitly imported function is extensible in the current module (@__MODULE__, e.g., Main).\nAlso see this post.","category":"page"},{"location":"importusing/#import-case","page":"Import and Using","title":"import case","text":"","category":"section"},{"location":"importusing/","page":"Import and Using","title":"Import and Using","text":"import .Bar\n\nBar.foo\n\nBar.foo(y) = Bar.x + y \n\nBar.x = 999\n\nBar.foo(3)","category":"page"},{"location":"importusing/#using-case","page":"Import and Using","title":"using case","text":"","category":"section"},{"location":"importusing/","page":"Import and Using","title":"Import and Using","text":"using .Bar2\n\nBar2.foo(y) = Bar2.x + y; Bar2.x = 999; foo(3)\n\nfoo(y) = Bar2.x + y","category":"page"},{"location":"importusing/#Where-does-imported-variable-points-to?","page":"Import and Using","title":"Where does imported variable points to?","text":"","category":"section"},{"location":"importusing/#The-import-case","page":"Import and Using","title":"The import case","text":"","category":"section"},{"location":"importusing/","page":"Import and Using","title":"Import and Using","text":"x imported to the current module (@__MODULE__) points to Bar3.x.\nYou cannot assign x in the current module.","category":"page"},{"location":"importusing/","page":"Import and Using","title":"Import and Using","text":"module Bar3\n    x = 1\n    foo() = x\n    export x\n    export foo\nend","category":"page"},{"location":"importusing/","page":"Import and Using","title":"Import and Using","text":"\nimport .Bar3: foo, x\n\nfoo(y) = x + y\n\nx = 9\n\nfoo(3)\n\nBar3.x = 333\n\nx\n\nfoo(3)\n\nBar3.x === x","category":"page"},{"location":"importusing/#The-using-case","page":"Import and Using","title":"The using case","text":"","category":"section"},{"location":"importusing/","page":"Import and Using","title":"Import and Using","text":"module Bar4\n    x = 1\n    foo() = x\n    export x\n    export foo\nend","category":"page"},{"location":"importusing/","page":"Import and Using","title":"Import and Using","text":"using .Bar4\n\nBar4.foo(y) = x + y\n\nx = 9.12\n\nBar4.x === x\n\nfoo(3)","category":"page"},{"location":"importusing/","page":"Import and Using","title":"Import and Using","text":"The behavior is strange, that the first call of x does matter.","category":"page"},{"location":"importusing/","page":"Import and Using","title":"Import and Using","text":"module Bar4\n    x = 1\n    foo() = x\n    export x\n    export foo\nend\n\nusing .Bar4\n\nx\n\nBar4.x === x\n\nx = 9.12","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = WorkingScopes","category":"page"},{"location":"#WorkingScopes","page":"Home","title":"WorkingScopes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"WorkingScopes.jl has no utility; it is merely a package of working examples for demonstration and experiments to understand Scope of Variables as well as Metaprogramming in julia programming.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for WorkingScopes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [WorkingScopes]","category":"page"},{"location":"#WorkingScopes.sayhello3-Tuple{Any}","page":"Home","title":"WorkingScopes.sayhello3","text":"sayhello3(name) = \"Hello world! $name\", an example to understand metaprogramming.\n\n\n\n\n\n","category":"method"},{"location":"#WorkingScopes.@sayhello3-Tuple{Expr}","page":"Home","title":"WorkingScopes.@sayhello3","text":"macro sayhello3(ex::Expr)\n    return Expr(:block, :(sayhello3($(last(ex.args)))))\nend\n\nExample: variable name is not defined in macro's scope\n\nname = \"Bruce Willey\"\n\n# output\n\"Bruce Willey\"\n\njulia> WorkingScopes.@sayhello3 $name\nERROR: UndefVarError: `name` not defined\n\ntip: Explain\nname is passed as expression in this case, and it is not defined since macro dispatch is not based on the AST evaluated at runtime. Thus an error of UndefVarError is raised.\nSee Macros and dispatch for more information.\n\nExample: a creative application\n\nWorkingScopes.@sayhello3 name = \"Bruce Willey\"\n\n# output\n\"Hello world! Bruce Willey\"\n\ntip: Explain\nIn this example, the last argument of the expression name = \"Bruce Willey\" is \"Bruce Willey\".\n\nExample 3: Use @eval if you want name be evaluated\n\n@eval WorkingScopes.@sayhello3 $name\n\n# output\n\"Hello world! Bruce Willey\"\n\ntip: Explain\n@eval evalute the expression @sayhello3 $name at runtime.\nThus, the argument for @sayhello3 is evaluated as String, and @sayhello3(str::String) is the dispatched method.\n\n\n\n\n\n","category":"macro"},{"location":"#WorkingScopes.@sayhello3-Tuple{String}","page":"Home","title":"WorkingScopes.@sayhello3","text":"macro sayhello3(str::String)\n    return Expr(:block, :(sayhello3($str)))\nend\n\nExample\n\nWorkingScopes.@sayhello3 \"Bruce Willey\"\n\n# output\n\"Hello world! Bruce Willey\"\n\n\n\n\n\n","category":"macro"},{"location":"#WorkingScopes.@sayhello3-Tuple{Symbol}","page":"Home","title":"WorkingScopes.@sayhello3","text":"macro sayhello3(symb::Symbol)\n    return Expr(:block, :(sayhello3($(string(symb)))))\nend\n\nExample: A single the runtime variable is rendered as Symbol\n\nname = \"Bruce Willey\"\nWorkingScopes.@sayhello3 name\n\n# output\n\"Hello world! name\"\n\n\n\n\n\n","category":"macro"}]
}
